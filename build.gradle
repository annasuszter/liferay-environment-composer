import com.bmuschko.gradle.docker.tasks.container.DockerCopyFileFromContainer

import groovy.json.JsonSlurper

import java.time.format.DateTimeFormatter

plugins {
	id "com.avast.gradle.docker-compose" version "0.17.10"
	id "docker-common"
	id "docker-liferay-bundle"
}

if (Boolean.getBoolean("env.mode.ci")) {
	formatSource {
		failOnAutoFix = true
	}
}

gradle.liferayWorkspace {
	dockerImageId = config.liferayDockerImageId
}

tasks.register("exportContainerData", DockerCopyFileFromContainer) {
	containerId = "${config.namespace}-data-helper"

	doFirst {
		mkdir hostPath.get()
	}

	hostPath = provider {
		DateTimeFormatter formatter = DateTimeFormatter.
		ofPattern("yyyyMMdd.HHmmss").
		withZone(ZoneId.systemDefault())

		"exported_data/data_${config.namespace}_${formatter.format(Instant.now())}"
	}

	remotePath = "/data/container-data"
}

tasks.register("prepareSelfSignedCert", Copy) {
	outputs.upToDateWhen {
		false
	}

	onlyIf {
		config.useWebserverHttps
	}

	List<String> hostnames = config.webserverHostnames
	.split(" ")
	.toList()

	File certDir = "compose-recipes/webserver-https/build/ssl" as File
	File opensslConfigFile = "$certDir/openssl.cnf" as File
	File certFile = "$certDir/server.crt" as File
	File keyFile = "$certDir/server.key" as File

	String sanEntries = hostnames
	.withIndex()
	.collect() {
		host, i -> "DNS.${i + 1} = ${host}"
	}
	.join('\n')

	from 'templates/webserver/ssl'

	include 'openssl.cnf.template'
	rename 'openssl.cnf.template', 'openssl.cnf'

	expand (hostname: hostnames[0], sanEntries: sanEntries)

	into certDir

	doLast {
		exec {
			commandLine 'openssl', 'req', '-x509',
			'-nodes',
			'-days', '365',
			'-newkey', 'rsa:2048',
			'-keyout', keyFile,
			'-out', certFile,
			'-config', opensslConfigFile
		}
	}
}

tasks.register("prepareWebserverConfig", Copy) {
	onlyIf("using a webserver") {
		config.useWebserverHttp || config.useWebserverHttps
	}

	outputs.upToDateWhen {
		false
	}

	File webserverConfigTemplatesDir = "templates/webserver/config" as File

	String upstreamConf = ""
	if (config.useWebserverHttp) {
		upstreamConf = config.useClustering ? file("$webserverConfigTemplatesDir/upstream-http.cluster.conf.template").text : file("$webserverConfigTemplatesDir/upstream-http.conf.template").text
	} else if (config.useWebserverHttps) {
		upstreamConf = config.useClustering ? file("$webserverConfigTemplatesDir/upstream-https.cluster.conf.template").text : file("$webserverConfigTemplatesDir/upstream-https.conf.template").text
	}

	from 'templates/webserver/config'

	include 'base.conf.template'
	rename 'base.conf.template', 'default.conf'
	expand(
		webserverConfig: config.useWebserverHttps ? file("$webserverConfigTemplatesDir/https.conf.template").text : file("$webserverConfigTemplatesDir/http.conf.template").text,
		webserverHostnames: config.webserverHostnames,
		upstreamConf: upstreamConf
	)

	if (config.useWebserverHttp) {
		into 'compose-recipes/webserver-http/build/config'
	} else if (config.useWebserverHttps) {
		into 'compose-recipes/webserver-https/build/config'
	}
}

tasks.register("shareWorkspace", Zip) {
	archiveFileName = provider {
		DateTimeFormatter formatter = DateTimeFormatter.
		ofPattern("yyyyMMdd.HHmmss").
		withZone(ZoneId.systemDefault())

		"workspace_${config.namespace}_${formatter.format(Instant.now())}.zip"
	}

	destinationDirectory = file 'shared_workspaces'

	doLast {
		logger.lifecycle "\nWorkspace zip: ${archiveFile.get()}\n"
	}

	exclude ".gitkeep"
	exclude ".gitignore"
	exclude ".git"
	exclude ".gradle"
	exclude "shared_workspaces"
	exclude {
		it.relativePath.pathString.startsWith("exported_data/") &&
		!it.relativePath.pathString.startsWith(config.dataDirectory)
	}

	from '.'

	include "${config.dataDirectory}/**"
	include "**/*"

	outputs.upToDateWhen {
		false
	}
}

tasks.register("restart") {
	dependsOn ":start"
	dependsOn ":stop"
}

tasks.register("start") {
	dependsOn ":composeUp"
	mustRunAfter ":stop"
}

tasks.register("stop") {
	dependsOn ":composeDown"
}

buildDockerImage {
	onlyIf("using the Liferay service") {
		config.useLiferay
	}
}

clean {
	dependsOn ":cleanPrepareHotfixes"
	dependsOn ":cleanPrepareSelfSignedCert"
	dependsOn ":cleanPrepareWebserverConfig"
}

dockerDeploy {
	dependsOn ":prepareHotfixes"
}

composeBuild {
	if (config.useWebserverHttp || config.useWebserverHttps) {
		dependsOn ":prepareWebserverConfig"
	}

	if (config.useWebserverHttps) {
		dependsOn ":prepareSelfSignedCert"
	}
}

composeUp {
	onlyIf("there are Compose files") {
		!config.composeFiles.isEmpty()
	}

	dependsOn ":buildDockerImage"
	dependsOn ":checkForLiferayLicense"

	doFirst {
		println "Using config:\n\n${config}\n\n"
	}

	finalizedBy ":listAdminUsers"
	finalizedBy ":printBundleInfo"
}

Map<String, String> environmentMap = [:]

environmentMap.put "DATA_DIRECTORY", config.dataDirectory
environmentMap.put "DATABASE_NAME", config.databaseName
environmentMap.put "NAMESPACE", config.namespace

if (config.useClustering) {
	environmentMap.put "LIFERAY_CLUSTER_NODES", config.clusterNodes
}

if (config.useLiferay) {
	environmentMap.put "LIFERAY_IMAGE_NAME", config.liferayDockerImageId
}

environmentMap.put("COMPOSE_FILE", config.composeFiles.join(File.pathSeparator))
environmentMap.put("COMPOSE_PROJECT_NAME", config.namespace.toLowerCase())

new File('.env').withOutputStream {
	BufferedOutputStream envFileOutputStream ->

	environmentMap.forEach {
		key, value ->

		envFileOutputStream << key << "=" << value << "\n"
	}
}

dockerCompose {
	// DEBUG: Set to true to print container startup output to the console
	captureContainersOutput = true

	// DEBUG: Uncomment to dump the container logs to a directory for inspection
	// captureContainersOutputToFiles = project.file('containerLogs')

	environment.putAll environmentMap

	projectName = config.namespace

	// DEBUG: Set to false to retain volume data on restart
	removeVolumes = true

	tcpPortsToIgnoreWhenWaiting = [8000, 11311]
	useComposeFiles = config.composeFiles

	// DEBUG: Set to true if container startup is failing
	retainContainersOnStartupFailure = false
}