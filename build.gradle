import com.bmuschko.gradle.docker.tasks.container.DockerCopyFileFromContainer

import de.undercouch.gradle.tasks.download.Download

import groovy.json.JsonSlurper

import java.time.format.DateTimeFormatter

plugins {
	id "com.avast.gradle.docker-compose" version "0.17.10"
}

File projectDir = project.projectDir as File

class Config {
	public List<String> hotfixURLs = new ArrayList<String>()
	public String namespace = "lrswde"
	public int clusterNodes = 0
	public List<String> composeFiles = new ArrayList<String>()
	public List<String> composeServices = new ArrayList<String>()
	public String databaseName = "lportal"
	public String dataDirectory = "data"
	public String liferayDockerImageId = ""

	@Override
	public String toString() {

		return """

Config:
------------------------
hotfixURLs: ${hotfixURLs}
namespace: ${namespace}
clusterNodes: ${clusterNodes}
composeFiles: ${composeFiles}
composeServices: ${composeServices}
databaseName: ${databaseName}
dataDirectory: ${dataDirectory}
liferayDockerImageId: ${liferayDockerImageId}

"""
	}
}

Config config = new Config()

config.composeFiles.add("docker-compose.yaml")
config.liferayDockerImageId = gradle.liferayWorkspace.dockerImageId as String

static List toList(String s) {
	return s.trim().split(",").grep()
}

Integer clusterNodes = project.getProperty("lr.docker.environment.cluster.nodes") as Integer
def composeFiles = toList(project.getProperty("lr.docker.environment.compose.files"))
List composeServices = project.properties.findAll {
	it.key =~ /^lr.docker.environment.compose.service.enabled\[\w+\]$/
}.findAll {
	it.value =~ /true|1/
}.collect {
	it.key.substring(it.key.indexOf("[") + 1, it.key.indexOf("]"))
}
String dataDirectory = project.getProperty("lr.docker.environment.data.directory")
String databaseName = project.getProperty("lr.docker.environment.database.name")
List hotfixURLs = toList(project.getProperty("lr.docker.environment.hotfix.urls"))
String namespace = project.getProperty("lr.docker.environment.namespace")

if (clusterNodes != null) {
	config.clusterNodes = clusterNodes
}

if (!composeServices.isEmpty()) {
	config.composeServices = composeServices
}

if (databaseName != null) {
	config.databaseName = databaseName
}

if (dataDirectory != null && dataDirectory.length() > 0) {
	config.dataDirectory = dataDirectory
}

if (!hotfixURLs.isEmpty()) {
	config.hotfixURLs = hotfixURLs
}

if (namespace != null) {
	config.namespace = namespace
}

boolean useLiferay = config.composeServices.contains("liferay")

boolean useClustering = useLiferay && config.clusterNodes > 0

ConfigurableFileTree dockerComposeFileTree = project.fileTree(projectDir) {
	include "**/docker-compose.*.yaml"

	if (useClustering) {
		include "**/clustering.*.yaml"
	}

	if (useLiferay) {
		include "**/liferay.*.yaml"

	}
}

List<String> possibleServices = dockerComposeFileTree.findAll{
	it.name.startsWith("docker-compose")
}.collect {
	it.name.substring("docker-compose.".length(), it.name.indexOf(".yaml"))
} as List<String>

List<String> composeServiceFiles = config.composeServices.collect {
	String service ->

	FileTree matchingFileTree = dockerComposeFileTree.matching {
		include "**/*.${service}.yaml"
	}

	if (matchingFileTree.isEmpty()) {
		throw new GradleException(
			"The service '${service}' does not have a matching docker-compose file. Possible services are: ${possibleServices}");
	}

	matchingFileTree.getFiles()
}.flatten().collect {
	projectDir.relativePath(it)
}

config.composeFiles.addAll(composeServiceFiles)

tasks.register("exportContainerData", DockerCopyFileFromContainer) {
	containerId = "${config.namespace}-data-helper"

	doFirst {
		mkdir hostPath.get()
	}

	hostPath = provider {
		DateTimeFormatter formatter = DateTimeFormatter.
		ofPattern("yyyyMMdd.HHmmss").
		withZone(ZoneId.systemDefault())

		"exported_data/data_${formatter.format(Instant.now())}"
	}

	remotePath = "/data/container-data"

}

tasks.register("prepareHotfixes", Download) {
	dest project.layout.dir(project.provider {project.file("configs/common/patching")})
	onlyIf {
		!config.hotfixURLs.isEmpty()
	}
	src config.hotfixURLs
}
tasks.register("possibleServices") {
	description "Displays the possible service names that can be used with docker-compose."
	doFirst {
		println "Possible services: ${possibleServices}"
	}
	group "help"
}

clean {
	dependsOn ":cleanPrepareHotfixes"
}
dockerDeploy {
	if (useLiferay) {
		dependsOn ":prepareHotfixes"
	}
}

composeUp {
	if (useLiferay) {
		dependsOn ":buildDockerImage"
	}

	doFirst {
		println "Using config: ${config}"
	}

	onlyIf {
		!config.composeFiles.isEmpty()
	}
}

dockerCompose {
	// DEBUG: Set to true to print container startup output to the console
	captureContainersOutput = false

	// DEBUG: Uncomment to dump the container logs to a directory for inspection
	// captureContainersOutputToFiles = project.file('containerLogs')

	environment.put "DATA_DIRECTORY", config.dataDirectory
	environment.put "DATABASE_NAME", config.databaseName
	environment.put "NAMESPACE", config.namespace

	if (useLiferay) {
		environment.put "LIFERAY_IMAGE_NAME", config.liferayDockerImageId
	}

	projectName = config.namespace

	// DEBUG: Set to false to retain volume data on restart
	removeVolumes = true

	if (useClustering) {
		scale = ["liferay-cluster-node": config.clusterNodes]
	}

	tcpPortsToIgnoreWhenWaiting = [8000, 11311]
	useComposeFiles = config.composeFiles

	// DEBUG: Set to true if container startup is failing
	retainContainersOnStartupFailure = false
}